package codegeneration.iaf_neuron_ode_module:

    neuron iaf_neuron_ode_neuron:

        state:
            - y0, y1, y2, V mV [y1 > 0; y2 > 0] # TODO - sollen nicht getrackt werden
            - r  integer
            # Membrane potential.
            alias V_m mV = V + E_L
        end

        parameter:
            # Capacity of the membrane

            C_m       pF = 250pF [C_m  > 0]
            # Membrane time constant.
            Tau     ms = 10 [Tau > 0]
            # Time constant of synaptic current.
            tau_in ms = 2
            # Refractory period.
            t_ref    ms = 2 s
            # Resting potential.
            E_L      mV = -70
            -delta_V_reset mV = -70 - E_L
            -Theta   mV = -55 - E_L

            # External current.
            I_e     pA = 0 # special

            # some aliases
            # Threshold.
            alias V_th mV = Theta + E_L
            # Reset value of the membrane potential.
            alias  V_reset mV = delta_V_reset + E_L
            # invariant V_reset >= Theta
        end

        internal:
            h   ms   = resolution()
            P30 real = 1 / C_m * (1 - P22) * tau_in

            PSCInitialValue  mV = 1 * E / tau_in
            RefractoryCounts integer = steps(t_ref)
        end

        input:
            spikeBuffer   <- inhibitory excitatory spike
            currentBuffer <- current
        end

        output: spike

        dynamics timestep(t ms):

            if r == 0: # not refractory
                ODE:
                    I_shape === w * (E/tau_in) * t * exp(-1/tau_in*t)
                    d/dt V === -1/Tau * V + 1/C_m*I_shape
                end
                V = P30 * (y0 + I_e) + P20 * y1 + P21 * y2 + P22 * V
            else:
                r = r - 1
            end

            # alpha shape PSCs
            y2 = P10 * y1 + P11 * y2
            y1 = y1 * P00

            # Apply spikes delivered in this step: The spikes arriving at T+1 have an
            # immediate effect on the state of the neuron
            y1 = y1 + PSCInitialValue * spikeBuffer.getSum(t)

            # threshold crossing
            if V >= Theta:
                r = RefractoryCounts
                V = delta_V_reset

                emitSpike()
            end

            # set new input current
            y0 = currentBuffer.getSum(t);
        end

        function set_V_th(v mV):
            Theta = v - E_L
        end

        function set_V_reset(v mV):
            delta_V_reset = v - E_L
        end

        function set_V_m(v mV):
            V = v - E_L
        end
    end
end

