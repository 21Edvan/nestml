package nest:

    neuron iaf_neuron:
        state:
            - y0, y1, y2, y3 mV [y1 > 0; y2 > 0] # TODO - sollen nicht getrackt werden
            - r  integer
            # Membrane potential.
            alias V_m mV = y3 + E_L
        end

        parameter:
            /* Capacity of the
            membrane.*/

            C_m       pF = 250pF [C_m  > 0]
            # Membrane time constant.
            tau_m     ms = 10 [tau_m > 0]
            # Time constant of synaptic current.
            tau_syn ms = 2
            # Refractory period.
            t_ref    ms = 2 s
            # Resting potential.
            E_L      mV = -70
            - delta_V_reset mV = -70 - E_L
            -Theta   mV = -55 - E_L
            # External current.
            I_e     pA = 0

            # some aliases
            # Threshold.
            alias V_th mV = Theta + E_L
            # Reset value of the membrane potential.
            alias  V_reset mV = delta_V_reset + E_L
            # invariant V_reset >= Theta
        end

        internal:
            h   ms   = Time.resolution()
            P11 real = E ** (-h / tau_syn)
            P22 real = P11
            P33 real = E ** (-h / tau_m)
            P21 real = h * P11
            P30 real = 1 / C_m * (1 - P33) * tau_m
            P31 real = 1 / C_m * ((P11 - P33) / (-1/tau_syn - -1/tau_m) - h * P11) / (-1/tau_m - -1/tau_syn)
            P32 real = 1 / C_m * (P33 - P11) / (-1/tau_m - -1/tau_syn)

            PSCInitialValue  mV = 1 * E / tau_syn
            RefractoryCounts integer = Time.steps(t_ref)
        end

        input:
            spikeBuffer   <- inhibitory excitatory spike
            currentBuffer <- current
        end

        output: spike

        dynamics timestep(t ms):
            if r == 0: # not refractory
                y3 = P30 * (y0 + I_e) + P31 * y1 + P32 * y2 + P33 * y3
            else:
                r = r - 1
            end

            # alpha shape PSCs
            y2 = P21 * y1 + P22 * y2
            y1 = y1 * P11

            # Apply spikes delivered in this step: The spikes arriving at T+1 have an
            # immediate effect on the state of the neuron
            y1 = y1 + PSCInitialValue * spikeBuffer.getSum(t)

            # threshold crossing
            if y3 >= Theta:
                r = RefractoryCounts
                y3 = delta_V_reset

                Spiking.emitSpike()
            end

            # set new input current
            y0 = currentBuffer.getSum(t);
        end

        function set_V_th(v mV):
            Theta = v - E_L
        end

        function set_V_reset(v mV):
            delta_V_reset = v - E_L
        end

        function set_V_m(v mV):
            y3 = v - E_L
        end
    end

    neuron iaf_tum_2000:
        state:
            i_0       mV
            i_syn_ex  mV
            i_syn_in  mV
            # membrane potential relative to zero
            delta_V_m mV

            - r_abs integer
            - r_tot integer

            # alias for the actual membrane potential
            alias V_m mV = E_L + delta_V_m
        end

        parameter:
            # Membrane time constant.
            tau_m         ms = 10.0
            # Membrane capacitance.
            C_m           pF = 250.0
            # Refractory period
            t_ref_abs     ms = 2.0
            # Refractory period
            t_ref_tot     ms = 2.0
            # Resting potential
            E_L           mV = -70.0
            # relative threshold
            delta_V_th   mV = 15.0
            # relative reset value
            delta_V_reset mV = 0.0
            # External current
            I_e           pA = 0.0
            # Time constant of excitatory synaptic current
            tau_syn_ex     ms = 2.0
            # Time constant of inhibitory synaptic current
            tau_syn_in     ms = 2.0

            # alias for the actual threshold
            alias V_th   mV = E_L + delta_V_th
            # alias for the actual reset value
            alias V_reset mV = E_L + delta_V_reset
        end

        internal:
            h     ms   = Time.resolution()

            P11ex real = pow(E, (-h / tau_syn_ex))
            P11in real = pow(E, (-h / tau_syn_in))
            P22   real = pow(E, (-h / tau_m))
            P21ex real = tau_m / (C_m * (1.0 - tau_m / tau_syn_ex)) * P11ex * (1.0 - pow(E, h * (1.0 / tau_syn_ex - 1.0 / tau_m)))
            P21in real = tau_m / (C_m * (1.0 - tau_m / tau_syn_in)) * P11in * (1.0 - pow(E, h * (1.0 / tau_syn_in - 1.0 / tau_m)))
            P20   real = tau_m / C_m * (1.0 - P22)

            RefrCountAbs integer = Time.steps(t_ref_abs)
            RefrCountTot integer = Time.steps(t_ref_tot)
        end

        input:
            inhBuffer      <- inhibitory spike
            excBuffer1      <- excitatory spike
            excBuffer2      <- excitatory spike
            currentBuffer  <- current
        end

        output: spike

        dynamics timestep(t ms):

            if r_abs == 0: # neuron not refractory, so evolve V
                delta_V_m = delta_V_m * P22 + i_syn_ex * P21ex + i_syn_in * P21in + (I_e + i_0) * P20
            else:
                r_abs = r_abs - 1 # neuron is absolute refractory
            end

            # exponential decaying PSCs
            i_syn_ex = i_syn_ex * P11ex
            i_syn_in = i_syn_in * P11in
            i_syn_ex = i_syn_ex + excBuffer1.getSum(t)    # the spikes arriving at T+1 have an
            i_syn_in = i_syn_in + inhBuffer.getSum(t)    # the spikes arriving at T+1 have an
                                                         # immediate effect on the state of the neuron

            if r_tot == 0:
                if V_m >= V_th:           # threshold crossing
                    r_abs  = RefrCountAbs
                    r_tot = RefrCountTot
                    V_m    = V_reset

                    Spiking.emitSpike()
                end
            else:
                r_tot = r_tot - 1
            end

            i_0 = currentBuffer.getSum(t)
        end

        function set_V_th(v mV):
            delta_V_th = v - E_L
        end

        function set_V_reset(v mV):
            delta_V_reset = v - E_L
        end

        function set_V_m(v mV):
            delta_V_m = v - E_L
        end
    end
end

