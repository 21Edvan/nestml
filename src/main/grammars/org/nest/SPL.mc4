/*
 * Copyright (c) 2015 RWTH Aachen. All rights reserved.
 *
 * http://www.se-rwth.de/
 */
package org.nest;

grammar SPL extends org.nest.Commons {

  SPLFile = ModuleDefinitionStatement Block;

  ModuleDefinitionStatement = "module" moduleName:QualifiedName;

  Block = ( Stmt | NEWLINE )*;

  Stmt = Simple_Stmt | Compound_Stmt;

  Compound_Stmt = IF_Stmt
                | FOR_Stmt
                | WHILE_Stmt;

  Simple_Stmt = Small_Stmt (";" Small_Stmt)* (";")? NEWLINE?;

  Small_Stmt = Assignment
             | FunctionCall
             | Declaration
             | ReturnStmt;

  OdeDeclaration  = (Eq | ODE | NEWLINE)+;
  Eq = lhsVariable:Name "=" rhs:Expr;
  ODE = lhsVariable:Name "\'" "=" rhs:Expr;

  Assignment = variableName:QualifiedName
    (assignment:["="] |
     compoundSum:["+="] |
     compoundMinus:["-="] |
     compoundProduct:["*="] |
     compoundQuotient:["/="]) Expr;

  // inherited PrimitiveType must be used here because otherwise the parser cannot distinguish
  // between fqn: boolean and "keyword" boolean
  Declaration =
    vars:Name ("," vars:Name)*
    Datatype
    ("<" sizeParameter:Name ">")?
    ( "=" Expr )? ;

  Datatype = ["integer"] |
         ["real"] |
         ["string"] |
         ["boolean"] |
         ["void"] |
         UnitType;
  UnitType = leftParentheses:"(" UnitType rightParentheses:")"
         | base:UnitType pow:["**"] exponent:IntLiteral
         | left:UnitType (timesOp:["*"] | divOp:["/"]) right:UnitType
         | unit:Name;
  ReturnStmt = "return" Expr?;

  IF_Stmt = IF_Clause
            ELIF_Clause*
            (ELSE_Clause)?
            BLOCK_CLOSE;
  IF_Clause = "if" Expr BLOCK_OPEN Block;

  ELIF_Clause = "elif" Expr BLOCK_OPEN Block;

  ELSE_Clause = "else" BLOCK_OPEN Block;

  FOR_Stmt = "for" var:Name "in" from:Expr "..." to:Expr ("step" step:SignedNumericLiteral)? BLOCK_OPEN Block BLOCK_CLOSE;

  WHILE_Stmt = "while" Expr BLOCK_OPEN Block BLOCK_CLOSE;

  /** ASTFunction a function definition:
      function set_V_m(v mV):
        y3 = v - E_L
      end
    @attribute name Functionname.
    @attribute parameters List with function parameters.
    @attribute returnType Complex return type, e.g. String
    @attribute primitiveType Primitive return type, e.g. int
    @attribute block Implementation of the function.
  */
  Function =
          "function" Name "(" Parameters? ")" (returnType:Datatype)?
           BLOCK_OPEN
             Block
           BLOCK_CLOSE;


  /** ASTParameters models parameter list in function declaration.
    @attribute parameters List with parameters.
  */
  Parameters = Parameter ("," Parameter)*;

  /** ASTParameter represents singe:
      output: spike
    @attribute compartments Lists with compartments.
  */
  Parameter = Name Datatype;

  Expr = leftParentheses:"(" Expr rightParentheses:")"
         | <rightassoc> base:Expr pow:["**"] exponent:Expr
         | (unaryPlus:["+"] | unaryMinus:["-"] | unaryTilde:["~"]) term:Expr
         | left:Expr (timesOp:["*"] | divOp:["/"] | moduloOp:["%"]) right:Expr
         | left:Expr (plusOp:["+"] | minusOp:["-"]) right:Expr
         | left:Expr (shiftLeft:["<<"] | shiftRight:[">>"]) right:Expr
         | left:Expr bitAnd:["&"] right:Expr
         | left:Expr bitXor:["^"]  right:Expr
         | left:Expr bitOr:["|"] right:Expr
         | left:Expr (lt:["<"] |
                      le:["<="] |
                      eq:["=="] |
                      ne:["!="] |
                      ne2:["<>"] |
                      ge:[">="] |
                      gt:[">"]) right:Expr
         | "not" Expr
         | left:Expr logicalAnd:["and"] right:Expr
         | left:Expr logicalOr:["or"] right:Expr
         | FunctionCall
         | BooleanLiteral // true & false;
         | NumericLiteral type:Name?
         | StringLiteral
         | ["inf"]
         | Variable;

  FunctionCall = name:QualifiedName "(" ArgList ")";

  ArgList = (args:Expr ("," args:Expr)*)?;

  Variable = name:QualifiedName;
}
